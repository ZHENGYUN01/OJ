#ifndef __OJ_H__#define __OJ_H__
/******************************************************************************//              定义系统中的各种错误码，错误码根据模块/特性进行分段管理******************************************************************************/
#define XDB_SUCCESS             (0)#define XDB_CORE_ERROR_BASE     (1) #define XDB_CORE_FRAMEWORK_ERROR_BASE (XDB_CORE_ERROR_BASE + 10000)#define XDB_CORE_OSWRAPPER_ERROR_BASE (XDB_CORE_ERROR_BASE + 20000)
/// 数据结构相关的通用错误码#define XDB_NULL_POINTER        (XDB_CORE_FRAMEWORK_ERROR_BASE + 1)#define XDB_OUT_OF_MEMORY       (XDB_CORE_FRAMEWORK_ERROR_BASE + 2)#define XDB_INDEX_OUT_OF_BOUNDS (XDB_CORE_FRAMEWORK_ERROR_BASE + 3)#define XDB_NO_SUCH_OBJECT      (XDB_CORE_FRAMEWORK_ERROR_BASE + 4)#define XDB_ILLEGAL_STATE       (XDB_CORE_FRAMEWORK_ERROR_BASE + 5)
/******************************************************************************//       定义全局宏******************************************************************************/
// 布尔类型定义#ifndef booleantypedef char boolean;#endif
#ifndef true#define true ((boolean) 1)#endif
#ifndef false#define false ((boolean) 0)#endif
//空指针定义#ifndef NULL#ifdef __cplusplus#define NULL    0#else#define NULL    ((void *)0)#endif#endif
/// Stack声明struct std_stack;typedef struct std_stack Stack;
//////////////////////////////////// Stack /////////////////////////////////////**********************************************************************功能:创建堆栈。
输入:N/A
输出:N/A     返回:创建的堆栈***********************************************************************/Stack* stack_create();
/**********************************************************************功能:释放整个堆栈，包括里面的数据。注意有相同数据（同一块内存）多次入栈  时，栈中元素的释放
输入:self：待删除的堆栈  free_object：堆栈中的数据元素内存释放接口
输出:N/A     返回:N/A***********************************************************************/void stack_distory(Stack* self, void (*free_object)(void* object));
/**********************************************************************功能:清空整个堆栈，与stack_destory不同，不释放数据元素的内存空间。
输入:self：待清空的堆栈
输出:N/A     返回:N/A***********************************************************************/void stack_clear(Stack* self);
/**********************************************************************功能:把项压入堆栈顶部。
输入:self：堆栈  data：压入堆栈的数据
输出:N/A     返回:N/A***********************************************************************/void stack_push(Stack* self, void* data);
/**********************************************************************功能:移除堆栈顶部的对象，并返回该对象。
输入:self：堆栈
输出:N/A     返回:堆栈顶部的对象***********************************************************************/void* stack_pop(Stack* self);
/**********************************************************************功能:查看堆栈顶部的对象，但不从堆栈中移除它。。
输入:self：堆栈
输出:N/A     返回:堆栈顶部的对象***********************************************************************/void* stack_peek(Stack* self);
/**********************************************************************功能:测试堆栈是否为空。
输入:self：堆栈
输出:N/A     返回:当且仅当堆栈中不含任何项时返回 true；否则返回 false。***********************************************************************/boolean stack_empty(Stack* self);
/**********************************************************************功能:返回对象在堆栈中的位置，以 1 为基数。  如果对象是堆栈中的一个项，此方法返回距堆栈顶部最近的出现位置  到堆栈顶部的距离；堆栈中最顶部项的距离为 1。
输入:self：堆栈  data：查找的对象  match：查找的对象的匹配函数。   match的形参data：栈中的data，此时的待匹配对象在match函数中，        向本函数屏蔽待查找对象的细节。 如果match为 NULL，才需要自行匹配栈中元素和search第二个形参data的指针。 如果match和data都为空，视为异常。
输出:N/A     返回:对象到堆栈顶部的位置，以 1 为基数；返回值 -1 表示不在堆栈中或存在异常。***********************************************************************/int stack_search(Stack* self, void* data, boolean (*match)(void* data));
#endif
